var search_data = {"index":{"searchIndex":["timers","events","handle","group","timer","wait",">()","after()","bisect_left()","call()","cancel()","cancel()","cancel!()","cancelled?()","continue()","continue()","current_offset()","delay()","delay()","every()","fire()","fire()","fire()","fire()","fires_in()","first()","for()","inspect()","new()","new()","new()","new()","new()","pause()","pause()","paused?()","pop()","reset()","resume()","resume()","schedule()","size()","time_remaining?()","to_f()","wait()","wait_interval()","while_time_remaining()"],"longSearchIndex":["timers","timers::events","timers::events::handle","timers::group","timers::timer","timers::wait","timers::events::handle#>()","timers::group#after()","timers::events#bisect_left()","timers::timer#call()","timers::group#cancel()","timers::timer#cancel()","timers::events::handle#cancel!()","timers::events::handle#cancelled?()","timers::group#continue()","timers::timer#continue()","timers::group#current_offset()","timers::group#delay()","timers::timer#delay()","timers::group#every()","timers::events#fire()","timers::events::handle#fire()","timers::group#fire()","timers::timer#fire()","timers::timer#fires_in()","timers::events#first()","timers::wait::for()","timers::timer#inspect()","timers::events::new()","timers::events::handle::new()","timers::group::new()","timers::timer::new()","timers::wait::new()","timers::group#pause()","timers::timer#pause()","timers::timer#paused?()","timers::events#pop()","timers::timer#reset()","timers::group#resume()","timers::timer#resume()","timers::events#schedule()","timers::events#size()","timers::wait#time_remaining?()","timers::events::handle#to_f()","timers::group#wait()","timers::group#wait_interval()","timers::wait#while_time_remaining()"],"info":[["Timers","","Timers.html","",""],["Timers::Events","","Timers/Events.html","","<p>Maintains an ordered list of events, which can be cancelled.\n"],["Timers::Events::Handle","","Timers/Events/Handle.html","","<p>Represents a cancellable handle for a specific timer event.\n"],["Timers::Group","","Timers/Group.html","",""],["Timers::Timer","","Timers/Timer.html","","<p>An individual timer set to fire a given proc at a given time. A timer is \nalways connected to a Timer::Group …\n"],["Timers::Wait","","Timers/Wait.html","","<p>An exclusive, monotonic timeout class.\n"],[">","Timers::Events::Handle","Timers/Events/Handle.html#method-i-3E","(other)",""],["after","Timers::Group","Timers/Group.html#method-i-after","(interval, &block)","<p>Call the given block after the given interval. The first argument will be\nthe time at which the group …\n"],["bisect_left","Timers::Events","Timers/Events.html#method-i-bisect_left","(a, e, l = 0, u = a.length)","<p>Return the left-most index where to insert item e, in a list a, assuming  a\nis sorted in descending order. …\n"],["call","Timers::Timer","Timers/Timer.html#method-i-call","(offset = @group.current_offset)",""],["cancel","Timers::Group","Timers/Group.html#method-i-cancel","()","<p>Cancel all timers.\n"],["cancel","Timers::Timer","Timers/Timer.html#method-i-cancel","()","<p>Cancel this timer. Do not call while paused.\n"],["cancel!","Timers::Events::Handle","Timers/Events/Handle.html#method-i-cancel-21","()","<p>Cancel this timer, O(1).\n"],["cancelled?","Timers::Events::Handle","Timers/Events/Handle.html#method-i-cancelled-3F","()","<p>Has this timer been cancelled? Cancelled timer&#39;s don&#39;t fire.\n"],["continue","Timers::Group","Timers/Group.html#method-i-continue","()",""],["continue","Timers::Timer","Timers/Timer.html#method-i-continue","()",""],["current_offset","Timers::Group","Timers/Group.html#method-i-current_offset","()","<p>The group&#39;s current time.\n"],["delay","Timers::Group","Timers/Group.html#method-i-delay","(seconds)","<p>Delay all timers.\n"],["delay","Timers::Timer","Timers/Timer.html#method-i-delay","(seconds)","<p>Extend this timer\n"],["every","Timers::Group","Timers/Group.html#method-i-every","(interval, recur = true, &block)","<p>Call the given block periodically at the given interval. The first \nargument will be the time at which …\n"],["fire","Timers::Events","Timers/Events.html#method-i-fire","(time)","<p>Fire all handles for which Handle#time is less than the given time.\n"],["fire","Timers::Events::Handle","Timers/Events/Handle.html#method-i-fire","(time)","<p>Fire the callback if not cancelled with the given time parameter.\n"],["fire","Timers::Group","Timers/Group.html#method-i-fire","(offset = self.current_offset)","<p>Fire all timers that are ready.\n"],["fire","Timers::Timer","Timers/Timer.html#method-i-fire","(offset = @group.current_offset)","<p>Fire the block.\n"],["fires_in","Timers::Timer","Timers/Timer.html#method-i-fires_in","()","<p>Number of seconds until next fire / since last fire\n"],["first","Timers::Events","Timers/Events.html#method-i-first","()","<p>Returns the first non-cancelled handle.\n"],["for","Timers::Wait","Timers/Wait.html#method-c-for","(duration, &block)",""],["inspect","Timers::Timer","Timers/Timer.html#method-i-inspect","()","<p>Inspect a timer\n"],["new","Timers::Events","Timers/Events.html#method-c-new","()",""],["new","Timers::Events::Handle","Timers/Events/Handle.html#method-c-new","(time, callback)",""],["new","Timers::Group","Timers/Group.html#method-c-new","()",""],["new","Timers::Timer","Timers/Timer.html#method-c-new","(group, interval, recurring = false, offset = nil, &block)",""],["new","Timers::Wait","Timers/Wait.html#method-c-new","(duration)",""],["pause","Timers::Group","Timers/Group.html#method-i-pause","()","<p>Pause all timers.\n"],["pause","Timers::Timer","Timers/Timer.html#method-i-pause","()",""],["paused?","Timers::Timer","Timers/Timer.html#method-i-paused-3F","()",""],["pop","Timers::Events","Timers/Events.html#method-i-pop","(time)","<p>Efficiently take k handles for which Handle#time is less than the given \ntime.\n"],["reset","Timers::Timer","Timers/Timer.html#method-i-reset","(offset = @group.current_offset)","<p>Reset this timer. Do not call while paused.\n"],["resume","Timers::Group","Timers/Group.html#method-i-resume","()","<p>Resume all timers.\n"],["resume","Timers::Timer","Timers/Timer.html#method-i-resume","()",""],["schedule","Timers::Events","Timers/Events.html#method-i-schedule","(time, callback)","<p>Add an event at the given time.\n"],["size","Timers::Events","Timers/Events.html#method-i-size","()","<p>Returns the number of pending (possibly cancelled) events.\n"],["time_remaining?","Timers::Wait","Timers/Wait.html#method-i-time_remaining-3F","()",""],["to_f","Timers::Events::Handle","Timers/Events/Handle.html#method-i-to_f","()",""],["wait","Timers::Group","Timers/Group.html#method-i-wait","(&block)","<p>Wait for the next timer and fire it. Can take a block, which should behave\nlike sleep(n), except that …\n"],["wait_interval","Timers::Group","Timers/Group.html#method-i-wait_interval","(offset = self.current_offset)","<p>Interval to wait until when the next timer will fire.\n<p>nil: no timers\n<p>-ve: timers expired already\n"],["while_time_remaining","Timers::Wait","Timers/Wait.html#method-i-while_time_remaining","(&block)","<p>Yields while time remains for work to be done:\n"]]}}